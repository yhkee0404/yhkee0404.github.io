{
  "hash": "a11b18f2463dd707787426d24e3d5949",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"이진수 대신 십진수를 쓰면 오차가 없어질까?\"\nauthor: \"Yunho Kee\"\ndate: \"2024-05-26\"\ndate-modified: \"2024-08-26\"\ncategories:\n  - algorithms\n  - float\n  - decimal\n  - double\n  - BigDecimal\n  - python\n  - java\nimage: /_images/thumbnails/elimende-inagella-4ApmfdVo32Q-unsplash.jpg\n---\n\n\n## Intro\n\n![Photo by <a href=\"https://unsplash.com/@elimendeinagella?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Elimende Inagella</a> on <a href=\"https://unsplash.com/photos/white-sheep-on-white-surface-4ApmfdVo32Q?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Unsplash</a>]({{< meta image >}}){fig-alt=\"A photo of 2+2=5.\"}\n\n정수 아닌 실수 연산은 오차 관리가 더 힘들다. 십진수를 쓰면 문제가 없을까?\n\n## 정수 오차\n\n저장 용량에 따른 자릿수를 초과하면 이진법이나 십진법이나 오차가 있다.\n\n## 실수 오차\n\n정수 아닌 실수도 마찬가지인데 소수점 이하 자릿수가 무한일 수 있다: 무한소수.\n\n::: {#5d9070ed .cell execution_count=1}\n``` {.python .cell-code}\nfive = 10 / 6 * 3\nfour = (7 - five) * 2\n\nprint(five, int(five))\nprint(four, int(four))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.0 5\n4.0 4\n```\n:::\n:::\n\n\n::: {#3e857d63 .cell execution_count=2}\n``` {.python .cell-code}\nfrom decimal import Decimal, ROUND_DOWN\n\nfive = Decimal('10') / Decimal('6') * Decimal('3')\nfour = (Decimal('7') - five) * Decimal('2')\n\nprint(five, int(five), five.quantize(Decimal('0'), ROUND_DOWN))\nprint(four, int(four), four.quantize(Decimal('0'), ROUND_DOWN))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.000000000000000000000000001 5 5\n3.999999999999999999999999998 3 3\n```\n:::\n:::\n\n\n## 오차 관리\n\n소수점 이하 무한한 자릿수가 모두 필요할 일은 거의 없다. 가령 소수점 이하 `n`번째 자리까지 필요하다면 그보다 작은 수를 가령 `n + 1`번째 자리에 `1`을 더하거나 빼 주면 된다. 더할 때는 절사, 절하, 내림, `ROUND_DOWN`이나 `ROUND_HALF_UP`이 필요할 때이다. 뺄 때는 절상, 올림, `ROUND_UP`이나 `ROUND_HALF_DOWN`이 요구될 때이다.\n\n::: {#5ccbf8bd .cell execution_count=3}\n``` {.python .cell-code}\n_EPSILON = 1e-2\n\nfive = 10 / 6 * 3\nfour = (7 - five) * 2 + _EPSILON\n\nfive_epsilon = five + _EPSILON\nprint(five_epsilon, int(five_epsilon))\nprint(four, int(four))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.01 5\n4.01 4\n```\n:::\n:::\n\n\n::: {#ae94ec30 .cell execution_count=4}\n``` {.python .cell-code}\nfrom decimal import Decimal, ROUND_DOWN\n\n_EPSILON = Decimal('1e-2')\n\nfive = Decimal('10') / Decimal('6') * Decimal('3')\nfour = (Decimal('7') - five) * Decimal('2') + _EPSILON\n\nfive_epsilon = five + _EPSILON\nprint(five_epsilon, int(five_epsilon), five_epsilon.quantize(Decimal('0'), ROUND_DOWN))\nprint(four, int(four), four.quantize(Decimal('0'), ROUND_DOWN))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.010000000000000000000000001 5 5\n4.009999999999999999999999998 4 4\n```\n:::\n:::\n\n\n## 언어 초월\n\nJava의 `BigDecimal`은 오차를 지역적으로 관리한다. 오차 관리가 필요할 때 Runtime에 `ArithmeticException`을 발생시킨다. 이처럼 반강제적인 예외 처리는 Python에서 발생할 오차를 일부 예방한다. 가령 연산 과정마다 주의하며 `RoundingMode` 그리고 `scale`이나 `precision` 등을 일일이 명시해야 지역적 오차로 인한 비정상 종료가 방지된다.\n\n하지만 일부 오차는 지역적 결과에 Greedy하게 의존하는 관리가 불가능하다. 가령 다음 예시의 `printNaiveBigDecimals`에서 5와 4를 동시에 얻을 수 없고 4와 4 또는 5와 3밖에 얻지 못한다는 한계가 있다.\n\n그래서 상기한 Epsilon 사용을 여전히 권장한다. 그러면 지역적 오차 관리 결과를 무시하고 원하는 다음 결과를 만들 수 있다. 즉 다음 예시의 `printEpsilonBigDecimals`에서 `divideRoundingMode`가 `RoundingMode.DOWN`, `RoundingMode.UP` 등 어느 것이었는지와 무관하게 5와 4를 동시에 만들 수 있다.\n\n```java\nimport java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\nclass DecimalRoundDown {\n\n    public static void main(final String[] args) {\n\n        printNaivePrimitiveDoubles();\n        \n        System.out.println();\n        printNaiveBigDecimals(RoundingMode.DOWN);\n        printNaiveBigDecimals(RoundingMode.UP);\n        \n        System.out.println();\n        printEpsilonPrimitiveDoubles();\n        \n        System.out.println();\n        printEpsilonBigDecimals(RoundingMode.DOWN);\n        printEpsilonBigDecimals(RoundingMode.UP);\n\n    }\n\n    private static void printNaivePrimitiveDoubles() {\n\n        final double five = 10. / 6 * 3;\n        final double four = (7 - five) * 2;\n\n        System.out.println(five + \" \" + (int) five);\n        System.out.println(four + \" \" + (int) four);\n\n    }\n\n    private static void printNaiveBigDecimals(final RoundingMode divideRoundingMode) {\n\n        BigDecimal five;\n        try {\n            five = new BigDecimal(\"10\")\n                    .divide(new BigDecimal(\"6\"))\n                    .multiply(new BigDecimal(\"3\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n            five = new BigDecimal(\"10\")\n                    .divide(new BigDecimal(\"6\"), 3, divideRoundingMode)\n                    .multiply(new BigDecimal(\"3\"));\n        }\n        final BigDecimal four = new BigDecimal(\"7\")\n                .subtract(five)\n                .multiply(new BigDecimal(\"2\"));\n\n        final MathContext mc = new MathContext(2, RoundingMode.DOWN);\n        System.out.println(five + \" \" + five.intValue() + \" \" + five.round(mc));\n        System.out.println(four + \" \" + four.intValue() + \" \" + four.round(mc));\n\n    }\n\n    private static void printEpsilonPrimitiveDoubles() {\n\n        final double EPSILON = 1e-2;\n\n        final double five = 10. / 6 * 3;\n        final double four = (7 - five) * 2 + EPSILON;\n\n        final double fiveEpsilon = five + EPSILON;\n        System.out.println(fiveEpsilon + \" \" + (int) fiveEpsilon);\n        System.out.println(four + \" \" + (int) four);\n\n    }\n\n    private static void printEpsilonBigDecimals(final RoundingMode divideRoundingMode) {\n\n        final BigDecimal EPSILON = new BigDecimal(\"1e-2\");\n\n        final BigDecimal five = new BigDecimal(\"10\")\n                .divide(new BigDecimal(\"6\"), 3, divideRoundingMode)\n                .multiply(new BigDecimal(\"3\"));\n        final BigDecimal four = new BigDecimal(\"7\")\n                .subtract(five)\n                .multiply(new BigDecimal(\"2\"))\n                .add(EPSILON);\n\n        final BigDecimal fiveEpsilon = five.add(EPSILON);\n        final MathContext mc = new MathContext(2, RoundingMode.DOWN);\n        System.out.println(fiveEpsilon + \" \" + fiveEpsilon.intValue() + \" \" + fiveEpsilon.round(mc));\n        System.out.println(four + \" \" + four.intValue() + \" \" + four.round(mc));\n\n    }\n\n}\n\n```\n\n```\n5.0 5\n4.0 4\n\njava.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.\n        at java.base/java.math.BigDecimal.divide(BigDecimal.java:1780)\n        at DecimalRoundDown.printNaiveBigDecimals(DecimalRoundDown.java:39)\n        at DecimalRoundDown.main(DecimalRoundDown.java:12)\n4.998 4 4.9\n4.004 4 4.0\njava.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.\n        at java.base/java.math.BigDecimal.divide(BigDecimal.java:1780)\n        at DecimalRoundDown.printNaiveBigDecimals(DecimalRoundDown.java:39)\n        at DecimalRoundDown.main(DecimalRoundDown.java:13)\n5.001 5 5.0\n3.998 3 3.9\n\n5.01 5\n4.01 4\n\n5.008 5 5.0\n4.014 4 4.0\n5.011 5 5.0\n4.008 4 4.0\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}