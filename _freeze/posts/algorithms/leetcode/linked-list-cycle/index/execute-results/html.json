{
  "hash": "c64fcfa286a54d412b94dad579eb893e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Two Pointers Speed Control\"\nsubtitle: \"Cycle 검사, Median, 시계\"\nauthor: \"Yunho Kee\"\ndate: \"2024-03-14\"\ncategories:\n  - featured\n  - leetcode\n  - programmers\n  - two pointers\n  - linked list\n  - cycle\n  - median\n  - clock\n  - speed\n  - 쥐쥐\n  - 백발백준\nimage: susan-q-yin-Ctaj_HCqW84-unsplash.jpg\n---\n\n## Intro\n\n![Photo by <a href=\"https://unsplash.com/@syinq?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Susan Q Yin</a> on <a href=\"https://unsplash.com/photos/people-sitting-on-white-concrete-stairs-Ctaj_HCqW84?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash\">Unsplash</a>](susan-q-yin-Ctaj_HCqW84-unsplash.jpg){fig-alt=\"A photo of poeple in a maze.\"}\n\n미로에서 전진만 반복했는데 아까 왔던 곳으로 되돌아왔다. 어떻게 알았을까?\n\n2가지 가능성이 있다. 첫째로, 한번 지나갔다는 것을 알 수 있도록 흔적을 남겨 놓았을 수 있다. 둘째로, 선발대와 후발대로 나뉜 다음 후발대가 선발대를 놓치지 않도록 충분히 긴 줄 등으로 연결한 상태에서 선발대가 빠르게 전진했을 수도 있다; 선발대가 후발대를 뒤에서 따라잡으면 두 집단을 연결하는 줄이 Cycle을 이룬다.\n\nGraph에서 Cycle을 검사하는 방법도 2가지 이상 있다. 첫째, 각 원소별 방문 여부를 저장한다. 둘째, Two Pointers 알고리즘을 활용한다.\n\n## Two Pointers\n\nTwo Pointers는 자료 구조를 탐색하는 Pointer(또는 Iterator)가 같은 원소를 재방문하지 않도록 보장하면서 복수의 Pointer로 각 자료 구조를 동시에 탐색하는 알고리즘이다. 자료 구조에 있는 원소의 개수가 최대 $n$개일 때 각 Pointer는 $n$개의 원소를 최대 1번씩 방문하다가 선형 시간 $O(n)$ 안에 탐색을 마친다. 따라서 총 수행 시간 $T(n)$은 Pointer의 개수 $k$에 비례한다: $T(n) = O(kn)$. 이에 비해 99라는 숫자를 셀 때 0부터 9를 10번 다시 세는 것처럼 각 Pointer의 지역적 중복 방문을 허용해 모든 방문 상태를 탐색하는 시간은 Cartesian Product를 $k$번 반복하므로 $k$에 따라 지수적으로 증가한다: $O(n^k)$. 가령, $k = 2$이면 $O(n^2) \\ne O(2n) = O(n)$이다. 이처럼 Two Pointers 수행 시간이 선형인 이유는 지역적인 재방문을 전역적으로 방지하기 때문이다; 한번 다녀간 원소에 처음부터 다시 와보는 등 돌이키지 못하고 오로지 전진만 허용한다.\n\n## Two Pointers를 통한 Graph Cycle 검사\n\nTwo Pointers 알고리즘을 통한 Cycle 검사의 장점은 방문 여부를 저장하지 않고도 중복 방문을 방지할 수 있다는 것이다. Graph에 Cycle이 없을 때는 재방문의 2가지 원인 중 첫째인 후진(Backtracking)만 안 하면 선형 탐색이 가능하다; 애초에 방문 여부나 경로 등을 전혀 저장하지 않고 후진하다가는 무한 루프에 갇히고 말 것이다. 재방문의 또다른 원인은 Cycle이다. Cycle이 있는 Graph에서는 전진 탐색은 물론이고 선발대가 후발대를 다시 만나는 즉시 Cycle로 판단해서 중단해야 한다.\n\nCycle 위의 Two Pointers로 Cycle 검사를 선형 시간 안에 수행하려면 선발대와 후발대의 속력 차가 $1$이면 된다. 그렇지 않으면 가령 선발대가 짝수번째 원소만 방문하고 후발대가 홀수번째만 방문할 때 경로가 겹치는 것처럼 보여도 두 집단은 영원히 만날 수 없다; 무한 루프에 갇힌다. 수학적으로는 다음과 같다: 선발대가 임의의 시점에 도착한 원소를 $0$부터 오름차순으로 $i_s$번째, 후발대는 $j_s$번째라고 하고, $i_s$와 $j_s$가 길이가 $m$인 Cycle 위에 있을 때 $t$ 시간을 더 탐색하면:\n\n::: {style=\"overflow-x: auto\"}\n$$\n\\begin{align}\n\\forall i_s, j_s \\in \\mathbb{Z}, \\forall m \\in \\mathbb{Z}^+ : \\exists t \\in \\mathbb{Z} \\text{ such that }  \\\\\n& & i_s + t         & \\equiv j_s        & \\pmod{m}\\;\\\\\n\\text{ and }\\\\\n& & 0 \\leq t        & < m.\\\\\n\\therefore \\forall a \\in \\mathbb{Z} :\\\\\n& & i_s + (a + 1)t  & \\equiv j_s + at   & \\pmod{m}.\n\\end{align}\n$$\n:::\n\n다시 말해 후발대가 $a$의 속력으로 이동할 때 선발대가 $a + 1$의 속력으로 더 빨리 전진하면서 Two Pointers 알고리즘을 진행하다가 두 집단이 $x$ 시점에 도착하는 $j_x = j_s + at$번째 원소와 $i_x = i_s + (a + 1)t$번째 원소가 $x = t$ 시점에서 처음으로 일치($i_x \\equiv j_x \\pmod{m}$)할 때 중단하는 Cycle 검사 알고리즘의 수행 시간은 선발대와 후발대가 이미 Cycle 위에 있을 때 $T_c(m) = O(m)$이다. 왜냐하면 $T_c(m) = O(t)$이고 $t = O(m)$이기 때문이다.\n\n일반적으로 원소의 개수가 $n$인 Graph를 탐색할 때 $i_0 = j_0 = 0$번째 원소가 Cycle 밖에 있더라도 정지하지 않는다면 즉 $a > 0$이면 Cycle 내 원소까지 선형 시간($T_u(n) = i_s - i_0 = O(n)$)에 가능한 한 반드시 도달한다. 또한 $m = O(n)$이다. 결론적으로 Two Pointers의 Cycle 검사 시간은:\n\n$$\n\\begin{align}\nT(n) & = T_u(n) + T_c(m)\\\\\n     & = O(n) + O(m)\\\\\n     & = O(n)\n\\end{align}\n$$\n\n## Linked List Cycle\n\nLeetCode 문제 [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)은 Linked List에 Cycle이 있는지 확인하는 문제이다. 처음에는 방문 흔적을 남기는 풀이밖에 몰랐다. 하지만 `Follow up`에서 상수 공간 복잡도를 요구하는 것을 보고 나니 선형 공간 복잡도로 만족할 수 없었다. 그래서 고민하던 중 같이 알고리즘 스터디를 하고 계신 [쥐쥐](https://leetcode.com/submissions/detail/1195224680/) 님의 풀이를 본 덕분에 이 글을 쓸 수 있었다. [다음](https://leetcode.com/submissions/detail/1202054400/) Python 풀이는 모든 양의 정수 `a`에 대해 동작한다:\n\n\n\n::: {#13f8e6aa .cell execution_count=2}\n``` {.python .cell-code}\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode], a = 1) -> bool:\n        node_i = head\n        node_j = head\n        while node_i is not None and node_j is not None:\n            for _ in range(a + 1):\n                node_i = node_i.next\n                if node_i is None:\n                    return False\n            for _ in range(a):\n                node_j = node_j.next\n                if node_j is None:\n                    return False\n            if node_i == node_j:\n                return True\n        return False\n```\n:::\n\n\n::: {#fb8fc19d .cell execution_count=3}\n``` {.python .cell-code}\nnodes = [ListNode(x) for x in [3,2,0,-4]]\nfor i in range(len(nodes) - 1):\n    nodes[i].next = nodes[i + 1]\nnodes[-1].next = nodes[1]\nhead = nodes[0]\n\nsol = Solution()\nall(sol.hasCycle(head, a) for a in range(1, 100))\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\nTrue\n```\n:::\n:::\n\n\n## Two Pointers Speed Control\n\nTwo Pointers Cycle 검사는 속력 차가 1이어야 했다. 정렬된 List에서 Median 찾기는 속력 차가 2배이면 된다. 홀수 $n$개 원소가 정렬된 List의 Median은 0부터 셀 때 $\\lfloor n / 2 \\rfloor$번째 원소이다. List가 배열이면 임의의 Index에 Random Access하는 데 상수 시간 $O(1)$이 걸리니 선형 시간의 Two Pointers가 더 느리다: $O(n) \\ne O(1)$. 반면에 Linked List에서 Two Pointers 알고리즘을 활용하면 $\\lfloor n / 2 \\rfloor$번째 원소를 찾을 때 $n$을 몰라도 된다는 장점이 있다. $\\forall q \\in \\mathbb{Z}^+$인 $n / q$번째 원소라면 속력 차가 $q$배면 되는 것이다.\n\n## Middle of the Linked List\n\nLeetCode 문제 [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)는 Linked List에서 가운데 원소(원소의 개수가 짝수이면 가운데 오른쪽)를 찾는 문제이다. 정렬된 List는 아니지만 Index 또는 가상의 기준으로 정렬돼 있다고 가정할 수 있다. 어차피 $\\lfloor n / 2 \\rfloor$번째 원소만 찾으면 된다. 원래는 $n$을 먼저 찾고 나서 절반을 되돌아가는 풀이밖에 몰랐다. 그러다 스터디에서 [백발백준](https://leetcode.com/submissions/detail/1196229225/) 님의 풀이를 보고 Two Pointers 접근을 새로 배웠다. [다음](https://leetcode.com/submissions/detail/1202349821/) Kotlin 풀이는 $n$도 모르고 Index 계산도 하지 않는다:\n\n```kotlin\n/**\n * Example:\n * var li = ListNode(5)\n * var v = li.`val`\n * Definition for singly-linked list.\n * class ListNode(var `val`: Int) {\n *     var next: ListNode? = null\n * }\n */\nclass Solution {\n    fun middleNode(head: ListNode?): ListNode? {\n        var node: ListNode? = head\n        var ans: ListNode? = head\n        var odd: Boolean = false\n        while (node !== null) {\n            node = node.next\n            if (odd) {\n                ans = ans!!.next\n            }\n            odd = odd xor true\n        }\n        return ans\n    }\n}\n```\n\n## 아날로그 시계\n\n프로그래머스 문제 [아날로그 시계](https://school.programmers.co.kr/learn/courses/30/lessons/250135)는 초침과 분침이 겹치거나 초침과 시침이 겹치는 횟수를 세는 문제이다. 시계는 Two Pointers와 달리 0부터 다시 세는 지역적 재방문을 허용해서 앞서 얘기한 Cartesian Product를 탐색한다. 가령 초 단위 디지털 시계는 $12 * 60 * 60$개 상태를 탐색하므로 $12 + 60 + 60$개를 탐색하는 Two Pointers 접근은 불가능하다. 방문 횟수는 탐색하며 저장할 필요 없이 시간 차의 몫과 나머지를 구하면 된다.\n\n문제는 지역적인 중복이 아니고 시계라는 자료 구조를 공유하는 Iterator 중 일부가 서로 같은 원소에 교차하는 횟수이다. 더 큰 문제는 아날로그 시계의 원소가 초 단위 디지털 정수가 아닌 실수 공간에 있다는 사실이다. [20-21](#cb5-20)번째와 [23-24](#cb5-23)번째 줄에서 실수 교차를 처리했다. 마지막으로 시침과 분침이 각각 초침과 겹치는 횟수를 구하는 것과 달리 모두 겹치면 중복으로 처리했다: [14](#cb5-14)번째, [27-28](#cb5-27)번째 줄.\n\n::: {#52a625dd .cell execution_count=4}\n``` {.python .cell-code code-line-numbers=\"true\"}\nMOD = 12 * 60 * 60\nDH = 1\nDM = 12\nDS = 12 * 60\nDSH = DS - DH\nDSM = DS - DM\n\ndef solution(h1, m1, s1, h2, m2, s2):\n    src = (h1 * 60 + m1) * 60 + s1\n    dest = (h2 * 60 + m2) * 60 + s2\n    hi = src % MOD\n    mi = (m1 * 60 + s1) * DM\n    si = s1 * DS\n    ans = 1 if any(xi == si for xi in [hi, mi]) else 0\n    for _ in range(src, dest):\n        hj = hi + DH\n        mj = mi + DM\n        sj = si + DS\n        sh = None\n        if hi > si and hj <= sj:\n            sh = (hi - si) * DSM\n        sm = None\n        if mi > si and mj <= sj:\n            sm = (mi - si) * DSH\n        bsh = sh is not None\n        bsm = sm is not None\n        if bsh or bsm:\n            ans += 2 if bsh and bsm and sh != sm else 1\n        hi = hj % MOD\n        mi = mj % MOD\n        si = sj % MOD\n    return ans\n```\n:::\n\n\n::: {#2121a12d .cell execution_count=5}\n``` {.python .cell-code}\ns = '''\\\n0\t5\t30\t0\t7\t0\t2\n12\t0\t0\t12\t0\t30\t1\n0\t6\t1\t0\t6\t6\t0\n11\t59\t30\t12\t0\t0\t1\n11\t58\t59\t11\t59\t0\t1\n1\t5\t5\t1\t5\t6\t2\n0\t0\t0\t23\t59\t59\t2852\n'''\nans = True\nfor line in s.strip().split('\\n'):\n    *args, result = map(eval, line.split('\\t'))\n    ans = ans and solution(*args) == result\nans\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\nTrue\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}